<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <title>Computing Tiles</title>
    <link rel="stylesheet" type="text/css" href="css/tiles.css">
    <link rel="stylesheet" type="text/css" href="dependencies/jquery-ui.min.css">
    <script type="text/javascript" src="dependencies/three.min.js"></script>
    <script type="text/javascript" src="dependencies/raphael-min.js"></script>
    <script type="text/javascript" src="dependencies/raphael.export.js"></script>
    <script type="text/javascript" src="dependencies/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="dependencies/jquery-ui.min.js"></script>
    <script type="text/javascript" src="dependencies/TrackballControls.js"></script>
    <script type="text/javascript" src="js/tile.js"></script>
    <script type="text/javascript" src="js/tile3d.js"></script>
    <script type="text/javascript" src="js/edgeTile.js"></script>
    <script type="text/javascript" src="js/cornerTile.js"></script>
    <script type="text/javascript" src="js/threeController.js"></script>
    <script type="text/javascript" src="js/svgExporter.js"></script>
    <script type="text/javascript" src="js/main.js"></script>
</head>

<body>
<div id="mainWrapper">

    <p>This week's assignment is to make a press fit construction kit from cardboard - an exercise in going from 2D to 3D by creating a set of parts that can produce a wide variety of 3D shapes.  I've done some similar projects with a 3D printer and straws (<a href="http://www.instructables.com/id/3D-Printed-Straw-Connectors-V3/">here</a>, <a href="http://www.instructables.com/id/3D-Printed-Straw-Connectors-V2/">here</a>, and <a href="http://www.instructables.com/id/3D-Printed-Straw-Sculptures/">here</a>), so for this week's assignment I wanted to go a little bit further and try to bring in the concepts of spatial computing into my designs.  That is, instead of using identical parts to construct a regular, symmetric lattice, designing a set of parts with information embedded in their geometry.  This way, the lattice assembles in meaningful, programmable ways.</p><p><img src="http://www.instructables.com/files/deriv/F7K/6JH1/I05F5B3K/F7K6JH1I05F5B3K.LARGE.jpg"></p><p>The inspiration for this project comes from the paper "Algorithmic Self-Assembly of DNA Sierpinski Triangles" by <a href="http://www.plosbiology.org/article/info%3Adoi%2F10.1371%2Fjournal.pbio.0020424#pbio-0020424-g006">Rothemund, Papadakis, and Winfree</a> (image above).  In the paper, Rothemund et al describe how they created a set of DNA tiles - modular pieces of DNA with four exposed "<a href="http://en.wikipedia.org/wiki/Sticky_and_blunt_ends">sticky ends</a>" - that spontaneously assemble into <a href="http://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinski Triangles</a>.  A set of four tiles was designed to exhibit the behavior of an <a href="http://en.wikipedia.org/wiki/XOR_gate">xor gate</a> for four possible input states.  When placed in aqueous medium and allowed to self assemble, sierpinski triangles are the logical spatial output.  Here is a great video that explains this in more depth:</p><iframe src="//player.vimeo.com/video/54214122?title=0&byline=0&portrait=0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen="" height="450" width="600" frameborder="0"></iframe><p>This concept is generalized in <a href="http://en.wikipedia.org/wiki/Wang_tile">Wang Tiles</a>, a set of tiles that must be arranged in an order dictated by their sides (image below).  Tiles may not rotate, and tiles may only touch other tiles if their sides the same color.  You might recognize these from your childhood - I think I might have played with a toy inspired by Wang Tiles as a kid.</p><p><img src="http://www.instructables.com/files/deriv/FS6/GLOZ/I05F5QTD/FS6GLOZI05F5QTD.LARGE.gif"></p><p>Though these logical tiles have some computational merit, I'm more interested in their potential for fabrication: controlling the patterning of features across a material.  If certain tile types can be engineered with special properties (conductor/insulator, photocurable/soluble, etc), then it might be possible to self assemble useful structures on very small scales.</p><p>Some work in assembling DNA in 3D using modular bits is being done.  <a href="http://www.sciencemag.org/content/338/6111/1177.short">DNA bricks</a> is an idea to build 3D structures of DNA from small pieces that can only fit together in pre-defined ways:</p><iframe src="//player.vimeo.com/video/53979004?title=0&byline=0&portrait=0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen="" height="338" width="600" frameborder="0"></iframe><p>This process has generated some nice results, but I'm not convinced it will scale well for larger geometries.  Since each voxel requires a unique brick type, the amount of bricks needed to make an N x N x N cube is N^3.  Requiring so many different raw materials for one synthesis increases production costs and may reduce the <a href="http://en.wikipedia.org/wiki/Binding_selectivity">specificity</a> of brick binding, especially as we try to build larger structures.  If we could somehow design geometries in a way that can be assembled by a smaller set of bricks in a programmatic fashion, the idea would be much more expandable.</p><p>In this week's project, I wanted to explore the concept of self-assembling logical bits in 3d, using cardboard as a model.  I started by thinking about building cube-like structures (3 inputs + 3 outputs = 6 faces total) that fit together as voxels in space, but had a hard time designing something elegant from 2d sheet that met all my requirements without too much complexity.</p><p><img src="http://cdn.instructables.com/FC7/GFFI/I05F557F/FC7GFFII05F557F.LARGE.jpg"></p><p>After some searching, I landed on the <a href="http://fab.cba.mit.edu/classes/MIT/862.06/students/george/">GIK design</a> as a way to bring 2D into a 3D lattice with sufficient interconnectedness.  As I started looking at GIK, I realized that I'd already used it once in another project - a set of modular shelves <a href="http://www.instructables.com/id/DIY-Modal-Designer-Shelves-T-Shelves/?ALLSTEPS">I built last year</a> based off <a href="http://www.j1studio.com/furniture/tshelf/">this design</a> (GIK using right triangles instead of squares).  One convenient property of GIK is that each module is a flat square, with four points of connection; this meant I could stick to the 2 input / 2 output model from the DNA tiles/Wang tiles examples and limit my tile set to only four tiles (4 possible input states).  </p><p>I began by building a scripted, parametric design tool for the tile design.  Last week I used <a href="http://raphaeljs.com/">RaphaelJS</a> to do some 2D graphics and animation.  This week I'm using Raphael, <a href="https://github.com/ElbertF/Raphael.Export">Raphael.Export</a>, and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob#Blob_constructor_example_usage">Blob API</a> to design and export SVG files to send into the laser cutter (download only working in Chrome so far).  I'm also using <a href="http://threejs.org/">ThreeJS</a> to render the assembly in 3D on the <a href="http://en.wikipedia.org/wiki/Canvas_element">canvas</a> to simulate what the "programmed" structure will look like (not quite done yet, but reeeeally close).   ThreeJS is a little more complicated than Raphael, and I've only used it once before, so this was a learning experience (<a href="http://threejs.org/docs/">here are the docs</a>). Note - I won't be using it this week, but three.js pairs nicely with <a href="https://github.com/envisprecisely/THREE2STL">THREE2STL</a> to export stl files directly from the browser. I used <a href="https://threejsdoc.appspot.com/doc/three.js/src.source/extras/controls/TrackballControls.js.html">TrackballControls.js</a> to add interactivity (pan, zoom, rotate) to the 3D model.   I'm also using <a href="http://jquery.com/download/">JQuery</a> and <a href="http://jqueryui.com">JQueryUI</a> for some UI components and helper functions.</p><p>The design tool is below (<a href="https://github.com/amandaghassaei/PressFitTiles">code here</a>).  The 2D tile editor lets you program your set of tiles.  One set of tile consists of four main tile types (for the four logical states of the inputs), four edge pieces, and one corner piece.  The input bits on each of the tiles is highlighted in yellow - these do not change.  You can toggle the output states by clicking on it in the editor.  Notice how the svg output updates when you toggle the output state of a tile.  In my system, the state of a tile input or output is controlled by the depth of the notch.  When constructing the lattice, short notches may only fit with deep notches and vice versa for the alignment to work out.  This constrains the way that tiles may attach to each other.</p><p>The parameters of the svg output are controlled by sliders and inputs.  The download button will save a copy of the svg output to your computer (again, Chrome only, I'm not sure what's up with that).</p><p>The 3D canvas is just a few lines short of showing a simulation of the assembled lattice (so close!)  For now it shows the assembly in a bunch of random colors.  When it's done, it will not show every tile in the lattice, only the tiles highlighted in red in the 2d tile designer.  This will draw attention to significant substructures of tiles within the lattice.  You will be able to click on a tile in the 2D editor to toggle its visibility in the 3D simulation.  By default I've highlighted all tiles with LSB = 1 in red.  The 3D canvas is interactive, drag to orbit, scroll to zoom and right click (two finger click on trackpad) to pan.</p>

    <div id="3dRenderer"></div>
    <div id="2dDesigner"></div>
    <div id="svgExporter"></div>
    <div id="uiControls">
        <div class="uiControlsSub">
            (all units in inches)<br/><br/>
            Notch Width: <input id="notchWidth" type="text"><br/>
            Tile Width: <input id="tileWidth" type="text"><br/>
        </div>
        <div class="uiControlsSub">
            <div>Chamfer:</div>
            <div id="chamfer" class="slider"></div>
            <div>Extra Edge Dimensions:</div>
            <div id="extraEdge" class="slider"></div>
        </div>
        <button id="exportSvg">Download Files</button>
    </div>

    <p>The tiles I cut are shown by default when the tile design tool loads.  Each tile is acting as a summer, outputting the sum of the two input states to the <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB</a> and <a href="http://en.wikipedia.org/wiki/Least_significant_bit">LSB</a> outputs.  My tiles of interest (shown in red) have an LSB = 1.  I imagine that these tiles will highlight a structure on my lattice that shows bit addition happening across space - though it's not entirely intuitive without a simulation or a physical model what that will look like.  I designed my edge and corner tiles as though their missing inputs were 1's.</p><p>I laser cut my files on an Epilog laser with a 0.155 notch width.  I cut the MSB and LSB tags with 5% power and 100 speed so that they were only etched on the surface of the tiles.</p><p><img src="http://www.instructables.com/files/deriv/FG5/6PES/I05F64H8/FG56PESI05F64H8.LARGE.jpg"></p><p>As with Wang Tiles, the orientation of the tiles during assembly is very important.  I assembled all my tiles starting from the bottom corner tile, building out and up so that MSB was always on the top edge (vertical tiles) or pointing in the direction of +y with the letters visible from the top (horizontal tiles).  Though it seems like this orientation constraint would break down in a self assembled lattice, it is really just a limitation of the cardboard model.  I could have created 4 states in the notch depths (2 for inputs and 2 for outputs) that physically prevents input/input and output/output pairing, but the cardboard pieces were just too small.  The differences in notch depth would have been subtle, I think it would have been confusing for the human assembler.</p><p>I colored certain tile types red (tiles with LSB = 1) and assembled them until I ran out of tiles.  Unfortunately, I ran out much sooner than I'd hoped.  Though I started to see some emergent patterns in my lattice, I didn't have enough to identify exactly what was going on - and what it had to do with summing bits.  Another problem is that the opaque cardboard material obscures the inner structures of the lattice, so it's really not the best material for this type of model.  This would probably look great in clear and colored acrylic.  Here are the patterns I saw on the first two layers of lattice:</p><p><img src="http://www.instructables.com/files/deriv/F4K/409E/I05F6I25/F4K409EI05F6I25.LARGE.jpg"><img src="http://www.instructables.com/files/deriv/FW7/QHWO/I05F6I6W/FW7QHWOI05F6I6W.LARGE.jpg">
</p><p>I'd like to continue thinking about this project and maybe work it into some future week's assignments, I think there is still a lot to explore.  Some things I'm interested in:</p><p><strong>more tiles</strong> - I didn't cut nearly enough tiles to fully explore the model I've got.  Since I didn't know which tiles would get used up the fastest, I cut equal amounts of everything.  Turns out I ran out of a few tiles very quickly and had a lot of extras of others.  I'd love to cut out a few more tiles when the laser isn't so busy.</p><p><strong>exploring more tile combinations</strong> - I've just recently got the simulator up and running, it's a great tool to design in before committing to a physical model.  I want to spend some time with the simulator looking at the possibilities, seeing if I can find some interesting emergent structures.</p><p><strong>different lattice structures</strong> - this week I've modeled this process on GIK, but what would this look like on other types of lattices?  Systems with voxels that have three inputs and three outputs?  other geometries (not based off a cube)?</p><p><strong>modified visualization</strong> - it might be easier to understand what's happening in the GIK lattice if I model each tile as a node instead of as a flat sheet in my 3d visualization.</p><p><strong>&gt;2 states</strong> - so far I've been working with a binary state system.  How would the output differ if there were more than 2 possible states for each connection?</p><p><strong>non-deterministic (probabilistic) algorithmic self assembly</strong> - In all my examples so far there is exactly one tile that can fit into any given space, but what if you designed some redundancy in your tile set?  If you created two tile types that had the same input states and mixed together both sets of tiles into your mixture in equal proportions, in other proportions?</p>

</div>
</body>
</html>